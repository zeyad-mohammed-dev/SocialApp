===== SocialApp\src\DB\models\Comment.model.ts =====
import { model, models, HydratedDocument, Schema, Types } from 'mongoose';
import { IPost } from './Post.model';

export interface IComment {
  createdBy: Types.ObjectId;
  postId: Types.ObjectId | Partial<IPost>;
  commentId?: Types.ObjectId;

  content?: string;
  attachments?: string[];

  likes?: Types.ObjectId[];
  tags?: Types.ObjectId[];

  freezedAt?: Date;
  freezedBy?: Types.ObjectId;

  restoredAt?: Date;
  restoredBy?: Types.ObjectId;

  createdAt: Date;
  updatedAt?: Date;
}

export type HCommentDocument = HydratedDocument<IComment>;

const commentSchema = new Schema<IComment>(
  {
    createdBy: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    postId: { type: Schema.Types.ObjectId, ref: 'Post', required: true },
    commentId: { type: Schema.Types.ObjectId, ref: 'Comment' },

    content: {
      type: String,
      minLength: 2,
      maxLength: 500000,
      required: function (): boolean {
        return !this.attachments?.length;
      },
    },
    attachments: [String],

    likes: [{ type: Schema.Types.ObjectId, ref: 'User' }],
    tags: [{ type: Schema.Types.ObjectId, ref: 'User' }],

    freezedAt: Date,
    freezedBy: { type: Schema.Types.ObjectId, ref: 'User' },

    restoredAt: Date,
    restoredBy: { type: Schema.Types.ObjectId, ref: 'User' },
  },
  {
    timestamps: true,
    strictQuery: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

commentSchema.pre(['findOne', 'find', 'countDocuments'], function (next) {
  const query = this.getQuery();
  if (query.paranoid === false) {
    this.setQuery({ ...query });
  } else {
    this.setQuery({ ...query, freezedAt: { $exists: false } });
  }

  next();
});

commentSchema.pre(['findOneAndUpdate', 'updateOne'], function (next) {
  const query = this.getQuery();
  if (query.paranoid === false) {
    this.setQuery({ ...query });
  } else {
    this.setQuery({ ...query, freezedAt: { $exists: false } });
  }

  next();
});

commentSchema.virtual('reply', {
  localField: '_id',
  foreignField: 'commentId',
  ref: 'Comment',
  justOne: true,
});
export const CommentModel =
  models.Comment || model<IComment>('Comment', commentSchema);
===== SocialApp\src\DB\models\FriendRequest.model.ts =====
import { model, models, HydratedDocument, Schema, Types } from 'mongoose';

export interface IFriendRequest {
  createdBy: Types.ObjectId;
  sendTo: Types.ObjectId;
  acceptedAt?: Date;

  createdAt: Date;
  updatedAt?: Date;
}

export type HFriendRequestDocument = HydratedDocument<IFriendRequest>;

const friendRequestSchema = new Schema<IFriendRequest>(
  {
    createdBy: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    sendTo: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    acceptedAt: Date,
  },
  {
    timestamps: true,
    strictQuery: true,
  }
);

friendRequestSchema.pre(['findOne', 'find', 'countDocuments'], function (next) {
  const query = this.getQuery();
  if (query.paranoid === false) {
    this.setQuery({ ...query });
  } else {
    this.setQuery({ ...query, freezedAt: { $exists: false } });
  }

  next();
});

friendRequestSchema.pre(['findOneAndUpdate', 'updateOne'], function (next) {
  const query = this.getQuery();
  if (query.paranoid === false) {
    this.setQuery({ ...query });
  } else {
    this.setQuery({ ...query, freezedAt: { $exists: false } });
  }

  next();
});


export const FriendRequestModel =
  models.FriendRequest ||
  model<IFriendRequest>('FriendRequest', friendRequestSchema);
===== SocialApp\src\DB\models\index.ts =====
export * from './User.model';
export * from './Post.model';
export * from './Token.model';
export * from './Comment.model';
export * from './FriendRequest.model';
===== SocialApp\src\DB\models\Post.model.ts =====
import { model, models, HydratedDocument, Schema, Types } from 'mongoose';

export enum AllowCommentsEnum {
  allow = 'allow',
  deny = 'deny',
}

export enum AvailabilityEnum {
  public = 'public',
  onlyMe = 'only-me',
  friends = 'friends',
}

export enum LikeActionEnum {
  like = 'like',
  unlike = 'unlike',
}

export interface IPost {
  content?: string;
  attachments?: string[];
  assetsFolderId: string;

  availability: AvailabilityEnum;
  allowComments: AllowCommentsEnum;

  likes?: Types.ObjectId[];
  tags?: Types.ObjectId[];

  createdBy: Types.ObjectId;

  freezedAt?: Date;
  freezedBy?: Types.ObjectId;

  restoredAt?: Date;
  restoredBy?: Types.ObjectId;

  createdAt: Date;
  updatedAt?: Date;
}

export type HPostDocument = HydratedDocument<IPost>;

const postSchema = new Schema<IPost>(
  {
    content: {
      type: String,
      minLength: 2,
      maxLength: 500000,
      required: function (): boolean {
        return !this.attachments?.length;
      },
    },
    attachments: [String],
    assetsFolderId: { type: String, required: true },

    availability: {
      type: String,
      enum: AvailabilityEnum,
      default: AvailabilityEnum.public,
    },
    allowComments: {
      type: String,
      enum: AllowCommentsEnum,
      default: AllowCommentsEnum.allow,
    },

    likes: [{ type: Schema.Types.ObjectId, ref: 'User' }],
    tags: [{ type: Schema.Types.ObjectId, ref: 'User' }],

    createdBy: { type: Schema.Types.ObjectId, ref: 'User', required: true },

    freezedAt: Date,
    freezedBy: { type: Schema.Types.ObjectId, ref: 'User' },

    restoredAt: Date,
    restoredBy: { type: Schema.Types.ObjectId, ref: 'User' },
  },
  {
    timestamps: true,
    strictQuery: true,
    toObject: { virtuals: true },
    toJSON: { virtuals: true },
  }
);

postSchema.pre(['findOne', 'find', 'countDocuments'], function (next) {
  const query = this.getQuery();
  if (query.paranoid === false) {
    this.setQuery({ ...query });
  } else {
    this.setQuery({ ...query, freezedAt: { $exists: false } });
  }

  next();
});

postSchema.pre(['findOneAndUpdate', 'updateOne'], function (next) {
  const query = this.getQuery();
  if (query.paranoid === false) {
    this.setQuery({ ...query });
  } else {
    this.setQuery({ ...query, freezedAt: { $exists: false } });
  }

  next();
});

postSchema.virtual('comments', {
  localField: '_id',
  foreignField: 'postId',
  ref: 'Comment',
  justOne: true,
});
export const PostModel = models.Post || model<IPost>('Post', postSchema);
===== SocialApp\src\DB\models\Token.model.ts =====
import { model, HydratedDocument } from 'mongoose';
import { models } from 'mongoose';
import { Schema } from 'mongoose';
import { Types } from 'mongoose';

export interface IToken {
  jti: string;
  expiresIn: number;
  userId: Types.ObjectId;
}

const tokenSchema = new Schema<IToken>(
  {
    jti: { type: String, required: true, unique: true },
    expiresIn: { type: Number, required: true },
    userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  },
  { timestamps: true }
);

export const TokenModel = models.Token || model<IToken>('Token', tokenSchema);
export type HTokenDocument = HydratedDocument<IToken>;
===== SocialApp\src\DB\models\User.model.ts =====
import { HydratedDocument, model, models, Schema, Types } from 'mongoose';
import { BadRequestException } from '../../utils/response/error.response';
import { generateHash } from '../../utils/security/hash.security';
import { emailEvent } from '../../utils/event/email.event';

export enum GenderEnum {
  male = 'male',
  female = 'female',
}

export enum RoleEnum {
  user = 'user',
  admin = 'admin',
  superAdmin = 'super-admin',
}

export enum ProviderEnum {
  GOOGLE = 'GOOGLE',
  SYSTEM = 'SYSTEM',
}

export interface IUser {
  // _id: Types.ObjectId;

  firstName: string;
  lastName: string;
  slug: string;
  username?: string;

  email: string;
  confirmEmailOtp?: string;
  confirmedAt?: Date;

  password: string;
  resetPasswordOTP?: string;
  changeCredentialsTime?: Date;

  phone?: string;
  address?: string;

  profileImage?: string;
  temProfileImage?: string;
  coverImages?: string[];

  gender: GenderEnum;
  role: RoleEnum;
  provider: ProviderEnum;

  freezedAt?: Date;
  freezedBy?: Types.ObjectId;
  restoredAt?: Date;
  restoredBy?: Types.ObjectId;
  friends?: Types.ObjectId[];

  createdAt: Date;
  updatedAt?: Date;
}

export type HUserDocument = HydratedDocument<IUser>;

const userSchema = new Schema<IUser>(
  {
    firstName: { type: String, required: true, minlength: 2, maxlength: 25 },
    lastName: { type: String, required: true, minlength: 2, maxlength: 25 },
    slug: { type: String, required: true, minlength: 5, maxlength: 51 },

    email: { type: String, required: true, unique: true },
    confirmEmailOtp: { type: String },
    confirmedAt: { type: Date },

    password: {
      type: String,
      required: function (): boolean {
        return this.provider === ProviderEnum.GOOGLE ? false : true;
      },
    },
    resetPasswordOTP: { type: String },
    changeCredentialsTime: { type: Date },

    phone: { type: String },
    address: { type: String },

    profileImage: { type: String },
    temProfileImage: { type: String },
    coverImages: [String],

    gender: { type: String, enum: GenderEnum, default: GenderEnum.male },
    role: { type: String, enum: RoleEnum, default: RoleEnum.user },
    provider: {
      type: String,
      enum: ProviderEnum,
      default: ProviderEnum.SYSTEM,
    },

    freezedAt: Date,
    freezedBy: { type: Schema.Types.ObjectId, ref: 'User' },
    restoredAt: Date,
    restoredBy: { type: Schema.Types.ObjectId, ref: 'User' },
    friends: [{ type: Schema.Types.ObjectId, ref: 'User' }],
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
    strictQuery: true,
  }
);

userSchema
  .virtual('username')
  .set(function (value: string) {
    const [firstName, lastName] = value.split(' ') || [];
    this.set({ firstName, lastName, slug: value.replaceAll(/\s+/g, '-') });
  })
  .get(function () {
    return this.firstName + ' ' + this.lastName;
  });

//signup pre
userSchema.pre(
  'save',
  async function (
    this: HUserDocument & { wasNew: boolean; confirmEmailPlainOtp?: string },
    next
  ) {
    this.wasNew = this.isNew;
    if (this.isModified('password')) {
      this.password = await generateHash(this.password);
    }
    if (this.isModified('confirmEmailOtp')) {
      this.confirmEmailPlainOtp = this.confirmEmailOtp as string;
      this.confirmEmailOtp = await generateHash(this.confirmEmailOtp as string);
    }
    next();
  }
);
userSchema.post('save', async function (doc, next) {
  const that = this as HUserDocument & {
    wasNew: boolean;
    confirmEmailPlainOtp?: string;
  };
  if (that.wasNew && that.confirmEmailPlainOtp) {
    emailEvent.emit('confirmEmail', {
      to: this.email,
      otp: that.confirmEmailPlainOtp,
      name: this.firstName,
    });
  }
  next();
});

//find hooks
userSchema.pre(['find', 'findOne'], function (next) {
  const query = this.getQuery();
  if (query.paranoid === false) {
    this.setQuery({ ...query });
  } else {
    this.setQuery({ ...query, freezedAt: { $exists: false } });
  }

  next();
});
// userSchema.pre(['find', 'findOne'], function (next) {
//   const query = this.getQuery();
//   console.log({
//     this: this,
//     query,
//     options: this.getOptions(),
//     op: this.model,
//   });
//   this.setOptions({ lean: false });
//   if (query.paranoid === false) {
//     this.setQuery({ ...query });
//   } else {
//     this.setQuery({ ...query, freezedAt: { $exists: false } });
//   }
//   this.populate({ path: 'freezedBy' });
//   next();
// });

// userSchema.pre(
//   'save',
//   async function (this: HUserDocument & { wasNew: boolean }, next) {
//     this.wasNew = this.isNew || this.isModified('email');
//     console.log({
//       pre_save: this,
//       isPasswordNew: this.isModified('password'),
//       newPaths: this.modifiedPaths(),
//       isNew: this.isNew,
//     });
//     if (this.isModified('password')) {
//       this.password = await generateHash(this.password);
//     }
//     next();
//   }
// );

// userSchema.post('save', function (doc, next) {
//   const that = this as HUserDocument & { wasNew: boolean };
//   console.log({
//     post_save: this,
//     doc,
//     isNew: that.wasNew,
//   });
//   if (that.wasNew) {
//     emailEvent.emit('confirmEmail', {
//       to: this.email,
//       otp: 545151,
//       name: this.username,
//     });
//   }
//   next();
// });

// userSchema.pre('validate', function (next) {
//   console.log({ pre: this });
//   if (!this.slug?.includes('-')) {
//     return next(
//       new BadRequestException(
//         "slug is required to have '-' between first name and last name"
//       )
//     );
//   }
//   next();
// });

// userSchema.post('validate', function (doc, next) {
//   console.log({ post: this });
//   next();
// });

export const UserModel = models.User || model<IUser>('User', userSchema);
===== SocialApp\src\DB\repository\comment.repository.ts =====
import { Model } from 'mongoose';
import { IComment as TDocument } from '../models';
import { DatabaseRepository } from './database.repository';

export class CommentRepository extends DatabaseRepository<TDocument> {
  constructor(protected override readonly model: Model<TDocument>) {
    super(model);
  }
}
===== SocialApp\src\DB\repository\database.repository.ts =====
import { DeleteResult } from 'mongoose';
import {
  MongooseUpdateQueryOptions,
  Types,
  UpdateQuery,
  UpdateWriteOpResult,
} from 'mongoose';
import {
  CreateOptions,
  FlattenMaps,
  HydratedDocument,
  Model,
  PopulateOptions,
  ProjectionType,
  QueryOptions,
  RootFilterQuery,
} from 'mongoose';

export type Lean<T> = HydratedDocument<FlattenMaps<T>>;

export abstract class DatabaseRepository<TDocument> {
  constructor(protected readonly model: Model<TDocument>) {}

  async find({
    filter,
    select,
    options,
  }: {
    filter?: RootFilterQuery<TDocument>;
    select?: ProjectionType<TDocument> | undefined;
    options?: QueryOptions<TDocument> | undefined;
  }): Promise<Lean<TDocument>[] | HydratedDocument<TDocument>[] | []> {
    const docs = this.model.find(filter || {}).select(select || '');
    if (options?.populate) {
      docs.populate(options.populate as PopulateOptions[]);
    }

    if (options?.limit) {
      docs.limit(options.limit);
    }
    if (options?.skip) {
      docs.skip(options.skip);
    }
    if (options?.lean) {
      docs.lean(options.lean);
    }
    return await docs.exec();
  }

  async paginate({
    filter = {},
    options = {},
    select,
    page = 'all',
    size = 5,
  }: {
    filter: RootFilterQuery<TDocument>;
    options?: QueryOptions<TDocument> | undefined;
    select?: ProjectionType<TDocument> | undefined;
    page?: number | 'all';
    size?: number;
  }): Promise<Lean<TDocument>[] | HydratedDocument<TDocument>[] | any> {
    let docsCount: number | undefined = undefined;
    let pages: number | undefined = undefined;

    if (page !== 'all') {
      page = Math.floor(page < 1 ? 1 : page);
      options.limit = Math.floor(size < 1 ? 5 : size);
      options.skip = (page - 1) * options.limit;

      docsCount = await this.model.countDocuments(filter);
      pages = Math.ceil(docsCount / options.limit);
    }
    const result = await this.find({ filter, select, options });
    return {
      docsCount,
      limit: options.limit,
      pages,
      currentPage: page !== 'all' ? page : undefined,
      result,
    };
  }

  async findOne({
    filter,
    select,
    options,
  }: {
    filter?: RootFilterQuery<TDocument>;
    select?: ProjectionType<TDocument> | null;
    options?: QueryOptions<TDocument> | null;
  }): Promise<Lean<TDocument> | HydratedDocument<TDocument> | null> {
    const doc = this.model.findOne(filter).select(select || '');
    if (options?.populate) {
      doc.populate(options.populate as PopulateOptions[]);
    }
    if (options?.lean) {
      doc.lean(options.lean);
    }
    return await doc.exec();
  }

  async findById({
    id,
    select,
    options,
  }: {
    id: Types.ObjectId;
    select?: ProjectionType<TDocument> | null;
    options?: QueryOptions<TDocument> | null;
  }): Promise<Lean<TDocument> | HydratedDocument<TDocument> | null> {
    const doc = this.model.findById(id).select(select || '');
    if (options?.populate) {
      doc.populate(options.populate as PopulateOptions[]);
    }
    if (options?.lean) {
      doc.lean(options.lean);
    }
    return await doc.exec();
  }

  async create({
    data,
    options,
  }: {
    data: Partial<TDocument>[];
    options?: CreateOptions | undefined;
  }): Promise<HydratedDocument<TDocument>[] | undefined> {
    return await this.model.create(data, options);
  }

  async updateOne({
    filter,
    update,
    options,
  }: {
    filter: RootFilterQuery<TDocument>;
    update: UpdateQuery<TDocument>;
    options?: MongooseUpdateQueryOptions<TDocument> | null;
  }): Promise<UpdateWriteOpResult> {
    if (Array.isArray(update)) {
      update.push({
        $set: {
          __v: { $add: ['$__v', 1] },
        },
      });
      return await this.model.updateOne(filter || {}, update, options);
    }
    console.log({ ...update, $inc: { __v: 1 } });
    return await this.model.updateOne(
      filter || {},
      { ...update, $inc: { __v: 1 } },
      options
    );
  }

  async deleteOne({
    filter,
  }: {
    filter: RootFilterQuery<TDocument>;
  }): Promise<DeleteResult> {
    return this.model.deleteOne(filter);
  }

  async deleteMany({
    filter,
  }: {
    filter: RootFilterQuery<TDocument>;
  }): Promise<DeleteResult> {
    return this.model.deleteMany(filter);
  }

  async findOneAndDelete({
    filter,
  }: {
    filter: RootFilterQuery<TDocument>;
  }): Promise<HydratedDocument<TDocument> | null> {
    return this.model.findOneAndDelete(filter);
  }

  async findByIdAndUpdate({
    id,
    update,
    options = { new: true },
  }: {
    id: Types.ObjectId;
    update: UpdateQuery<TDocument>;
    options?: QueryOptions<TDocument> | null;
  }): Promise<Lean<TDocument> | HydratedDocument<TDocument> | null> {
    return this.model.findByIdAndUpdate(
      id,
      { ...update, $inc: { __v: 1 } },
      options
    );
  }

  async findOneAndUpdate({
    filter,
    update,
    options = { new: true },
  }: {
    filter?: RootFilterQuery<TDocument>;
    update: UpdateQuery<TDocument>;
    options?: QueryOptions<TDocument> | null;
  }): Promise<Lean<TDocument> | HydratedDocument<TDocument> | null> {
    return this.model.findOneAndUpdate(
      filter,
      { ...update, $inc: { __v: 1 } },
      options
    );
  }
}
===== SocialApp\src\DB\repository\friendRequest.repository.ts =====
import { Model } from 'mongoose';
import { IFriendRequest as TDocument } from './../models/FriendRequest.model';
import { DatabaseRepository } from './database.repository';

export class FriendRequestRepository extends DatabaseRepository<TDocument> {
  constructor(protected override readonly model: Model<TDocument>) {
    super(model);
  }
}
===== SocialApp\src\DB\repository\index.ts =====
export * from './token.repository';
export * from './user.repository';
export * from './post.repository';
export * from './comment.repository';
export * from './friendRequest.repository';
===== SocialApp\src\DB\repository\post.repository.ts =====
import { IPost as TDocument } from './../models/Post.model';
import { Model, QueryOptions } from 'mongoose';
import { DatabaseRepository, Lean } from './database.repository';
import { RootFilterQuery } from 'mongoose';
import { ProjectionType } from 'mongoose';
import { HydratedDocument } from 'mongoose';
import { PopulateOptions } from 'mongoose';
import { CommentRepository } from './comment.repository';
import { CommentModel } from '../models';

export class PostRepository extends DatabaseRepository<TDocument> {
  private commentModel = new CommentRepository(CommentModel);

  constructor(protected override readonly model: Model<TDocument>) {
    super(model);
  }

  async findCursor({
    filter,
    select,
    options,
  }: {
    filter?: RootFilterQuery<TDocument>;
    select?: ProjectionType<TDocument> | undefined;
    options?: QueryOptions<TDocument> | undefined;
  }): Promise<Lean<TDocument>[] | HydratedDocument<TDocument>[] | [] | any> {
    let result = [];

    const cursor = this.model
      .find(filter || {})
      .select(select || '')
      .populate(options?.populate as PopulateOptions[])
      .cursor();

    for (
      let doc = await cursor.next();
      doc != null;
      doc = await cursor.next()
    ) {
      const comments = await this.commentModel.find({
        filter: { postId: doc._id, commentId: { $exists: false } },
      });

      result.push({ post: doc, comments });
    }
    return result;
  }
}
===== SocialApp\src\DB\repository\token.repository.ts =====
import { Model } from "mongoose";
import { IToken, IToken as TDocument } from "../models/Token.model";
import { DatabaseRepository } from "./database.repository";




export class TokenRepository extends DatabaseRepository<TDocument> {

constructor(protected override readonly model : Model<TDocument>){
    super(model)
}


}
===== SocialApp\src\DB\repository\user.repository.ts =====
import { DatabaseRepository } from './database.repository';
import { IUser as TDocument } from '../models/User.model';
import { Model } from 'mongoose';
import { CreateOptions } from 'mongoose';
import { HydratedDocument } from 'mongoose';
import { BadRequestException } from '../../utils/response/error.response';

export class UserRepository extends DatabaseRepository<TDocument> {
  constructor(protected override readonly model: Model<TDocument>) {
    super(model);
  }

  async createUser({
    data,
    options,
  }: {
    data: Partial<TDocument>[];
    options?: CreateOptions;
  }): Promise<HydratedDocument<TDocument>> {
    const [user] = (await this.create({ data, options })) || [];

    if (!user) {
      throw new BadRequestException('Fail to signup this user data');
    }
    return user;
  }
}
===== SocialApp\src\DB\connection.db.ts =====
import { connect } from 'mongoose';
import { log } from 'node:console';
import { UserModel } from './models/User.model';

const connectDB = async (): Promise<void> => {
  try {
    const result = await connect(process.env.DB_URI as string, {
      serverSelectionTimeoutMS: 30000,
    });

    await UserModel.syncIndexes();
    console.log(result.models);
    console.log('DB connected successfully ðŸš€');
  } catch (error) {
    log('Fail to connect on DB âŒ');
  }
};

export default connectDB;
===== SocialApp\src\DB\index.ts =====
export * from './models';
export * from './repository';
===== SocialApp\src\middlewares\authentication.middleware.ts =====
import { NextFunction, Request, Response } from 'express';
import {
  ForbiddenException,
  UnauthorizedException,
} from '../utils/response/error.response';
import { decodeToken, TokenEnum } from '../utils/security/token.security';
import { RoleEnum } from '../DB/models/User.model';

export const authentication = (tokenType: TokenEnum = TokenEnum.access) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (!req.headers.authorization) {
      throw new UnauthorizedException('Missing authorization header', {
        key: 'header',
        issue: [
          {
            path: 'authorization',
            message: 'Authorization header is required',
          },
        ],
      });
    }
    const { user, tokenPayload, level } = await decodeToken({
      authorization: req.headers.authorization,
      tokenType,
    });

    req.user = user;
    req.tokenPayload = tokenPayload;
    req.level = level;
    next();
  };
};

export const authorization = (
  accessRoles: RoleEnum[] = [],
  tokenType: TokenEnum = TokenEnum.access
) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (!req.headers.authorization) {
      throw new UnauthorizedException('Missing authorization header', {
        key: 'header',
        issue: [
          {
            path: 'authorization',
            message: 'Authorization header is required',
          },
        ],
      });
    }
    const { user, tokenPayload, level } = await decodeToken({
      authorization: req.headers.authorization,
      tokenType,
    });

    if (!accessRoles.includes(user.role)) {
      throw new ForbiddenException('Not authorized account');
    }

    req.user = user;
    req.tokenPayload = tokenPayload;
    req.level = level;
    next();
  };
};
===== SocialApp\src\middlewares\index.ts =====
export * from './authentication.middleware';
export * from './validation.middleware';
===== SocialApp\src\middlewares\validation.middleware.ts =====
import { file, z } from 'zod';
import type { NextFunction, Request, Response } from 'express';
import type { ZodError, ZodType } from 'zod';
import { BadRequestException } from '../utils/response/error.response';
import { Types } from 'mongoose';

type KeyReqType = keyof Request;

type SchemaType = Partial<Record<KeyReqType, ZodType>>;

type validationErrorsType = Array<{
  key: KeyReqType;
  issues: Array<{
    message: string;
    path: (string | number | symbol | undefined)[];
  }>;
}>;

export const validation = (schema: SchemaType) => {
  return (req: Request, res: Response, next: NextFunction): NextFunction => {
    const validationErrors: validationErrorsType = [];
    for (const key of Object.keys(schema) as KeyReqType[]) {
      if (!schema[key]) continue;

      if (req.file) {
        req.body.attachment = req.file;
      }
      if (req.files) {
        console.log(req.files);
        req.body.attachments = req.files;
      }

      const validationResult = schema[key].safeParse(req[key]);

      if (!validationResult.success) {
        const errors = validationResult.error as ZodError;

        validationErrors.push({
          key,
          issues: errors.issues.map((issue) => {
            return { message: issue.message, path: issue.path };
          }),
        });
      }
    }

    if (validationErrors.length) {
      throw new BadRequestException('Validation Error', {
        validationErrors,
      });
    }

    return next() as unknown as NextFunction;
  };
};

export const generalFields = {
  username: z
    .string({ error: 'username is required ' })
    .min(2, { error: 'min username length is 2 char' })
    .max(20, { error: 'max username length is 20 char' }),
  email: z.email({ error: 'valid email must be like to example@domain.com' }),
  password: z
    .string()
    .regex(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[a-zA-Z]).{8,}$/),
  confirmPassword: z.string(),
  otp: z.string().regex(/^[0-9]{6}$/, 'Invalid OTP format'),

  file: function (mimetype: string[]) {
    return z
      .strictObject({
        fieldname: z.string(),
        originalname: z.string(),
        encoding: z.string(),
        mimetype: z.enum(mimetype),
        buffer: z.any().optional(),
        path: z.string().optional(),
        size: z.number(),
      })
      .refine(
        (data) => {
          return data.buffer || data.path;
        },
        { error: 'File must have either buffer or path', path: ['file'] }
      );
  },

  id: z.string().refine(
    (data) => {
      return Types.ObjectId.isValid(data);
    },
    { error: 'Invalid tag ID' }
  ),
};
===== SocialApp\src\modules\auth\auth.controller.ts =====
import * as validators from './auth.validation';
import { validation } from '../../middlewares/validation.middleware';
import authServices from './auth.service';
import { Router } from 'express';
const router = Router();

router.post('/signup', validation(validators.signup), authServices.signup);
router.post('/login', validation(validators.login), authServices.login);

router.post('/signup-gmail' , validation(validators.signupWithGmail),authServices.signupWithGmail)
router.post('/login-gmail' , validation(validators.signupWithGmail),authServices.loginWithGmail)

router.patch('/confirm-email', validation(validators.confirmEmail), authServices.confirmEmail);
router.patch('/send-forget-password', validation(validators.sendForgetPasswordCode), authServices.sendForgetPasswordCode);
router.patch('/verify-forget-password', validation(validators.verifyForgetPasswordCode), authServices.verifyForgetPasswordCode);
router.patch('/reset-forget-password', validation(validators.resetForgetPassword), authServices.resetForgetPassword);

export default router;
===== SocialApp\src\modules\auth\auth.dto.ts =====
import { z } from 'zod';
import * as validators from './auth.validation';

export type ISignupBodyInputsDTO = z.infer<typeof validators.signup.body>;
export type ILoginBodyInputsDTO = z.infer<typeof validators.login.body>;

export type IGmailBodyInputsDTO = z.infer<typeof validators.signupWithGmail.body>;

export type IConfirmEmailBodyInputsDTO = z.infer<typeof validators.confirmEmail.body>;
export type IForgetCodeBodyInputsDTO = z.infer<typeof validators.sendForgetPasswordCode.body>;
export type IVerifyForgetPasswordCodeBodyInputsDTO = z.infer<typeof validators.verifyForgetPasswordCode.body>;
export type IResetForgetPasswordBodyInputsDTO = z.infer<typeof validators.resetForgetPassword.body>;




 
===== SocialApp\src\modules\auth\auth.entities.ts =====
export interface ILoginResponse {
  credentials: {
    access_token: string;
    refresh_token: string;
  };
}

export interface ILoginWithGmailResponse extends ILoginResponse {}

export interface ISignupWithGmailResponse extends ILoginResponse {}
===== SocialApp\src\modules\auth\auth.service.ts =====
import type { Request, Response } from 'express';
import type {
  IConfirmEmailBodyInputsDTO,
  IForgetCodeBodyInputsDTO,
  IGmailBodyInputsDTO,
  ILoginBodyInputsDTO,
  IResetForgetPasswordBodyInputsDTO,
  ISignupBodyInputsDTO,
  IVerifyForgetPasswordCodeBodyInputsDTO,
} from './auth.dto';

import { ProviderEnum, UserModel } from '../../DB/models/User.model';
import { UserRepository } from '../../DB/repository';
import {
  BadRequestException,
  ConflictException,
  NotFoundException,
} from '../../utils/response/error.response';
import { compareHash, generateHash } from '../../utils/security/hash.security';
import { emailEvent } from '../../utils/event/email.event';
import { generateNumberOtp } from '../../utils/helpers/otp';
import { createLoginCredentials } from '../../utils/security/token.security';
import { OAuth2Client, type TokenPayload } from 'google-auth-library';
import { successResponse } from '../../utils/response/success.response';
import {
  ILoginResponse,
  ILoginWithGmailResponse,
  ISignupWithGmailResponse,
} from './auth.entities';

class AuthenticationService {
  private userModel = new UserRepository(UserModel);
  constructor() {}

  private async verifyGoogleAccount(idToken: string): Promise<TokenPayload> {
    const client = new OAuth2Client();
    const ticket = await client.verifyIdToken({
      idToken,
      audience: process.env.WEB_CLIENT_IDs?.split(',') || [],
    });
    const payload = ticket.getPayload();
    if (!payload?.email_verified) {
      throw new BadRequestException('Failed to verify Google account');
    }
    return payload;
  }

  loginWithGmail = async (req: Request, res: Response): Promise<Response> => {
    const { idToken }: IGmailBodyInputsDTO = req.body;
    const { email } = await this.verifyGoogleAccount(idToken);

    const user = await this.userModel.findOne({
      filter: {
        email,
        provider: ProviderEnum.GOOGLE,
      },
    });

    if (!user) {
      throw new NotFoundException(
        'No account associated with this Gmail, please signup first'
      );
    }

    const credentials = await createLoginCredentials(user);

    return successResponse<ILoginWithGmailResponse>({
      res,
      data: { credentials },
    });
  };

  signupWithGmail = async (req: Request, res: Response): Promise<Response> => {
    const { idToken }: IGmailBodyInputsDTO = req.body;
    const { email, given_name, family_name, name, picture } =
      await this.verifyGoogleAccount(idToken);

    const user = await this.userModel.findOne({
      filter: {
        email,
      },
    });

    if (user) {
      if (user.provider === ProviderEnum.GOOGLE) {
        return await this.loginWithGmail(req, res);
      }
      throw new ConflictException(
        `Email exist with another provider ${user.provider} `
      );
    }

    const newUser = await this.userModel.createUser({
      data: [
        {
          email: email as string,
          provider: ProviderEnum.GOOGLE,
          firstName: given_name as string,
          lastName: family_name as string,
          profileImage: picture as string,
          confirmedAt: new Date(),
        },
      ],
    });

    const credentials = await createLoginCredentials(newUser);

    return successResponse<ISignupWithGmailResponse>({
      res,
      statusCode: 201,
      data: { credentials },
    });
  };

  signup = async (req: Request, res: Response): Promise<Response> => {
    let { username, email, password }: ISignupBodyInputsDTO = req.body;

    const checkUserExist = await this.userModel.findOne({
      filter: { email },
      select: 'email',
      options: { lean: true },
    });

    if (checkUserExist) {
      throw new ConflictException('Email exist');
    }

    const otp = generateNumberOtp();

    await this.userModel.createUser({
      data: [
        {
          username,
          email,
          password,
          confirmEmailOtp: otp,
        },
      ],
    });

    return successResponse({ res, statusCode: 201 });
  };

  confirmEmail = async (req: Request, res: Response): Promise<Response> => {
    const { email, otp }: IConfirmEmailBodyInputsDTO = req.body;

    const user = await this.userModel.findOne({
      filter: {
        email,
        confirmEmailOtp: { $exists: true },
        confirmedAt: { $exists: false },
      },
    });

    if (!user) {
      throw new NotFoundException('Invalid email or already confirmed');
    }

    if (!(await compareHash(otp, user.confirmEmailOtp as string))) {
      throw new ConflictException('Invalid OTP');
    }

    await this.userModel.updateOne({
      filter: { email },
      update: {
        confirmedAt: new Date(),
        $unset: { confirmEmailOtp: 1 },
      },
    });

    return successResponse({ res });
  };

  login = async (req: Request, res: Response): Promise<Response> => {
    const { email, password }: ILoginBodyInputsDTO = req.body;

    const user = await this.userModel.findOne({
      filter: { email, provider: ProviderEnum.SYSTEM },
    });
    if (!user) {
      throw new NotFoundException('Invalid credentials');
    }
    if (!user.confirmedAt) {
      throw new BadRequestException('Please confirm your email before login');
    }
    if (!(await compareHash(password, user.password))) {
      throw new BadRequestException('Invalid credentials');
    }

    const credentials = await createLoginCredentials(user);

    return successResponse<ILoginResponse>({ res, data: { credentials } });
  };

  sendForgetPasswordCode = async (
    req: Request,
    res: Response
  ): Promise<Response> => {
    const { email }: IForgetCodeBodyInputsDTO = req.body;

    const user = await this.userModel.findOne({
      filter: {
        email,
        provider: ProviderEnum.SYSTEM,
        confirmedAt: { $exists: true },
      },
    });
    if (!user) {
      throw new NotFoundException('No account associated with this email');
    }

    const otp = generateNumberOtp();

    const result = await this.userModel.updateOne({
      filter: { email },
      update: { resetPasswordOTP: await generateHash(String(otp)) },
    });

    if (!result.matchedCount) {
      throw new BadRequestException(
        'Failed to send reset code, please try again'
      );
    }

    console.log(email);
    emailEvent.emit('resetPasswordOTP', {
      to: email,
      otp,
      name: user.username,
    });

    return successResponse({ res });
  };

  verifyForgetPasswordCode = async (
    req: Request,
    res: Response
  ): Promise<Response> => {
    const { email, otp }: IVerifyForgetPasswordCodeBodyInputsDTO = req.body;
    const user = await this.userModel.findOne({
      filter: {
        email,
        provider: ProviderEnum.SYSTEM,
        resetPasswordOTP: { $exists: true },
      },
    });
    if (!user) {
      throw new NotFoundException('No account associated with this email');
    }

    if (!(await compareHash(otp, user.resetPasswordOTP as string))) {
      throw new ConflictException('Invalid OTP');
    }

    return successResponse({ res });
  };

  resetForgetPassword = async (
    req: Request,
    res: Response
  ): Promise<Response> => {
    const { email, otp, password }: IResetForgetPasswordBodyInputsDTO =
      req.body;
    const user = await this.userModel.findOne({
      filter: {
        email,
        provider: ProviderEnum.SYSTEM,
        resetPasswordOTP: { $exists: true },
      },
    });
    if (!user) {
      throw new NotFoundException('No account associated with this email');
    }

    if (!(await compareHash(otp, user.resetPasswordOTP as string))) {
      throw new ConflictException('Invalid OTP');
    }

    const result = await this.userModel.updateOne({
      filter: { email },
      update: {
        password: await generateHash(password),
        $unset: { resetPasswordOTP: 1 },
        changeCredentialsTime: new Date(),
      },
    });

    if (!result.matchedCount) {
      throw new BadRequestException(
        'Failed to reset password, please try again'
      );
    }

    return successResponse({ res });
  };
}

export default new AuthenticationService();
===== SocialApp\src\modules\auth\auth.validation.ts =====
import { email, z } from 'zod';
import { generalFields } from '../../middlewares/validation.middleware';

export const login = {
  body: z.strictObject({
    email: generalFields.email,
    password: generalFields.password,
  }),
};

export const signup = {
  body: login.body
    .extend({
      username: generalFields.username,
      confirmPassword: generalFields.confirmPassword,
    })
    .superRefine((data, ctx) => {
      if (data.confirmPassword !== data.password) {
        ctx.addIssue({
          code: 'custom',
          path: ['confirmPassword'],
          message: 'Password and Confirm Password do not match',
        });
      }
    }),
};

export const confirmEmail = {
  body: z.strictObject({
    email: generalFields.email,
    otp: generalFields.otp,
  }),
};

export const signupWithGmail = {
  body: z.strictObject({
    idToken: z.string(),
  }),
};

export const sendForgetPasswordCode = {
  body: z.strictObject({
    email: generalFields.email,
  }),
};

export const verifyForgetPasswordCode = {
  body: sendForgetPasswordCode.body.extend({
    otp: generalFields.otp,
  }),
};

export const resetForgetPassword = {
  body: verifyForgetPasswordCode.body
    .extend({
      password: generalFields.password,
      confirmPassword: generalFields.confirmPassword,
    })
    .refine(
      (data) => {
        return data.password === data.confirmPassword;
      },
      {
        message: 'Password and Confirm Password do not match',
        path: ['confirmPassword'],
      }
    ),
};
===== SocialApp\src\modules\auth\index.ts =====
export {default as router}  from "./auth.controller"
===== SocialApp\src\modules\comment\comment.authorization.ts =====
===== SocialApp\src\modules\comment\comment.controller.ts =====
import { Router } from 'express';
import { authentication } from '../../middlewares/authentication.middleware';
import {
  couldFileUpload,
  fileValidation,
} from '../../utils/multer/cloud.multer';
import commentService from './comment.service';
import * as validators from './comment.validation';
import { validation } from '../../middlewares';

const router = Router({ mergeParams: true });

router.post(
  '/',
  authentication(),
  couldFileUpload({ validation: fileValidation.image }).array('attachments', 2),
  validation(validators.createComment),
  commentService.createComment
);

router.post(
  '/:commentId/reply',
  authentication(),
  couldFileUpload({ validation: fileValidation.image }).array('attachments', 2),
  validation(validators.replyOnComment),
  commentService.replyOnComment
);

export default router;
===== SocialApp\src\modules\comment\comment.dto.ts =====
===== SocialApp\src\modules\comment\comment.entities.ts =====
===== SocialApp\src\modules\comment\comment.service.ts =====
import { Request, Response } from 'express';
import {
  AllowCommentsEnum,
  CommentModel,
  CommentRepository,
  HPostDocument,
  PostModel,
  PostRepository,
  UserModel,
  UserRepository,
} from '../../DB';
import {
  BadRequestException,
  deleteFiles,
  NotFoundException,
  StorageEnum,
  successResponse,
  uploadFiles,
} from '../../utils';
import { postAvailability } from '../post';
import { Types } from 'mongoose';

class CommentService {
  private userModel = new UserRepository(UserModel);
  private postModel = new PostRepository(PostModel);
  private commentModel = new CommentRepository(CommentModel);
  constructor() {}

  createComment = async (req: Request, res: Response): Promise<Response> => {
    const { postId } = req.params as unknown as { postId: Types.ObjectId };
    const post = await this.postModel.findOne({
      filter: {
        _id: postId,
        allowComments: AllowCommentsEnum.allow,
        $or: postAvailability(req),
      },
    });

    if (!post) {
      throw new NotFoundException('fail to find matching result');
    }
    if (
      req.body.tags?.length &&
      (
        await this.userModel.find({
          filter: { _id: { $in: req.body.tags, $ne: req.user?._id } },
        })
      ).length !== req.body.tags.length
    ) {
      throw new NotFoundException(
        'One or more tagged users not found or you try to tag your self'
      );
    }

    let attachments: string[] = [];
    if (req.files?.length) {
      attachments = await uploadFiles({
        storageApproach: StorageEnum.memory,
        path: `users/${post.createdBy}/post/${post.assetsFolderId}/comments`,
        files: req.files as Express.Multer.File[],
      });
    }

    const [comment] =
      (await this.commentModel.create({
        data: [
          {
            ...req.body,
            attachments,
            postId,
            createdBy: req.user?._id,
          },
        ],
      })) || [];

    if (!comment) {
      if (attachments?.length) {
        await deleteFiles({ urls: attachments });
      }
      throw new BadRequestException('Failed to create comment');
    }

    return successResponse({ res, statusCode: 201 });
  };

  replyOnComment = async (req: Request, res: Response): Promise<Response> => {
    const { postId, commentId } = req.params as unknown as {
      postId: Types.ObjectId;
      commentId: Types.ObjectId;
    };
    const comment = await this.commentModel.findOne({
      filter: {
        _id: commentId,
        postId,
      },
      options: {
        populate: [
          {
            path: 'postId',
            match: {
              allowComments: AllowCommentsEnum.allow,
              $or: postAvailability(req),
            },
          },
        ],
      },
    });

    if (!comment?.postId) {
      throw new NotFoundException('fail to find matching result');
    }
    if (
      req.body.tags?.length &&
      (
        await this.userModel.find({
          filter: { _id: { $in: req.body.tags, $ne: req.user?._id } },
        })
      ).length !== req.body.tags.length
    ) {
      throw new NotFoundException(
        'One or more tagged users not found or you try to tag your self'
      );
    }

    let attachments: string[] = [];
    if (req.files?.length) {
      const post = comment.postId as Partial<HPostDocument>;
      attachments = await uploadFiles({
        storageApproach: StorageEnum.memory,
        path: `users/${post.createdBy}/post/${post.assetsFolderId}/comments`,
        files: req.files as Express.Multer.File[],
      });
    }

    const [reply] =
      (await this.commentModel.create({
        data: [
          {
            ...req.body,
            attachments,
            postId,
            commentId,
            createdBy: req.user?._id,
          },
        ],
      })) || [];

    if (!reply) {
      if (attachments?.length) {
        await deleteFiles({ urls: attachments });
      }
      throw new BadRequestException('Failed to create reply');
    }

    return successResponse({ res, statusCode: 201 });
  };
}

export default new CommentService();
===== SocialApp\src\modules\comment\comment.validation.ts =====
import z from 'zod';
import { fileValidation } from '../../utils/multer/cloud.multer';
import { generalFields } from '../../middlewares';

export const createComment = {
  params: z.strictObject({ postId: generalFields.id }),
  body: z
    .strictObject({
      content: z.string().min(2).max(500000).optional(),
      attachments: z
        .array(generalFields.file(fileValidation.image))
        .max(2)
        .optional(),

      tags: z.array(generalFields.id).max(10).optional(),
    })
    .superRefine((data, ctx) => {
      if (!data.attachments?.length && !data.content) {
        ctx.addIssue({
          code: 'custom',
          path: ['content'],
          message: 'Either content or attachments must be provided',
        });
      }

      if (
        data.tags?.length &&
        data.tags.length !== [...new Set(data.tags)].length
      ) {
        ctx.addIssue({
          code: 'custom',
          path: ['tags'],
          message: 'Duplicated tagged users',
        });
      }
    }),
};

export const replyOnComment = {
  params: createComment.params.extend({
    commentId: generalFields.id,
  }),
  body: createComment.body,
};
===== SocialApp\src\modules\comment\index.ts =====
export { default as commentRouter } from './comment.controller';
===== SocialApp\src\modules\post\index.ts =====
export { default as router } from './post.controller';
export { postAvailability } from './post.service';
===== SocialApp\src\modules\post\post.authorization.ts =====
===== SocialApp\src\modules\post\post.controller.ts =====
import { postService } from './post.service';
import { validation } from '../../middlewares/validation.middleware';
import * as validators from './post.validation';
import { authentication } from '../../middlewares/authentication.middleware';
import {
  couldFileUpload,
  fileValidation,
} from '../../utils/multer/cloud.multer';

import { Router } from 'express';
import { commentRouter } from '../comment';

const router = Router();

router.use('/:postId/comment', commentRouter);
router.get('/', authentication(), postService.postList);

router.post(
  '/',
  authentication(),
  couldFileUpload({ validation: fileValidation.image }).array('attachments', 2),
  validation(validators.createPost),
  postService.createPost
);

router.patch(
  '/:postId',
  authentication(),
  couldFileUpload({ validation: fileValidation.image }).array('attachments', 2),
  validation(validators.updatePost),
  postService.updatePost
);

router.patch(
  '/:postId/like',
  authentication(),
  validation(validators.likePost),
  postService.likePost
);

export default router;
===== SocialApp\src\modules\post\post.dto.ts =====
import z from 'zod';
import { likePost } from './post.validation';

export type LikePostQueryInputsDto = z.infer<typeof likePost.query>;
===== SocialApp\src\modules\post\post.entities.ts =====
===== SocialApp\src\modules\post\post.service.ts =====
import { Request, Response } from 'express';
import { successResponse } from '../../utils/response/success.response';
import {
  CommentRepository,
  PostRepository,
  UserRepository,
} from '../../DB/repository';
import { UserModel } from '../../DB/models/User.model';
import {
  AvailabilityEnum,
  HPostDocument,
  LikeActionEnum,
  PostModel,
} from '../../DB/models/Post.model';
import {
  BadRequestException,
  NotFoundException,
} from '../../utils/response/error.response';
import { deleteFiles, uploadFiles } from '../../utils/multer/s3.config';
import { v4 as uuid } from 'uuid';
import { LikePostQueryInputsDto } from './post.dto';
import { Types, UpdateQuery } from 'mongoose';
import { CommentModel } from '../../DB';

export const postAvailability = (req: Request) => {
  return [
    { availability: AvailabilityEnum.public },
    { availability: AvailabilityEnum.onlyMe, createdBy: req.user?._id },
    {
      availability: AvailabilityEnum.friends,
      createdBy: { $in: [...(req.user?.friends || []), req.user?._id] },
    },
    {
      availability: { $ne: AvailabilityEnum.onlyMe },
      tags: { $in: req.user?._id },
    },
  ];
};

class PostService {
  private userModel = new UserRepository(UserModel);
  private postModel = new PostRepository(PostModel);

  constructor() {}

  createPost = async (req: Request, res: Response): Promise<Response> => {
    if (
      req.body.tags?.length &&
      (
        await this.userModel.find({
          filter: { _id: { $in: req.body.tags, $ne: req.user?._id } },
        })
      ).length !== req.body.tags.length
    ) {
      throw new NotFoundException(
        'One or more tagged users not found or you try to tag your self'
      );
    }

    let attachments: string[] = [];
    let assetsFolderId: string = uuid();
    if (req.files?.length) {
      attachments = await uploadFiles({
        files: req.files as Express.Multer.File[],
        path: `users/${req.user?._id}/post/${assetsFolderId}`,
      });
    }

    const [post] =
      (await this.postModel.create({
        data: [
          {
            ...req.body,
            attachments,
            assetsFolderId,
            createdBy: req.user?._id,
          },
        ],
      })) || [];

    if (!post) {
      if (attachments?.length) {
        await deleteFiles({ urls: attachments });
      }
      throw new BadRequestException('Failed to create post');
    }

    return successResponse({
      res,
      statusCode: 201,
      message: 'Post created successfully',
      data: {},
    });
  };

  updatePost = async (req: Request, res: Response): Promise<Response> => {
    const { postId } = req.params as unknown as { postId: Types.ObjectId };

    const post = await this.postModel.findOne({
      filter: { _id: postId, createdBy: req.user?._id },
    });
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    if (
      req.body.tags?.length &&
      (
        await this.userModel.find({
          filter: { _id: { $in: req.body.tags, $ne: req.user?._id } },
        })
      ).length !== req.body.tags.length
    ) {
      throw new NotFoundException('One or more tagged users not found');
    }

    let attachments: string[] = [];
    if (req.files?.length) {
      attachments = await uploadFiles({
        files: req.files as Express.Multer.File[],
        path: `users/${post.createdBy}/post/${post.assetsFolderId}`,
      });
    }

    const updatedPost = await this.postModel.updateOne({
      filter: { _id: post._id },
      update: [
        {
          $set: {
            content: req.body.content,
            allowComments: req.body.allowComments || post.allowComments,
            availability: req.body.availability || post.availability,
            attachments: {
              $setUnion: [
                {
                  $setDifference: [
                    '$attachments',
                    req.body.removedAttachments || [],
                  ],
                },
                attachments,
              ],
            },
            tags: {
              $setUnion: [
                {
                  $setDifference: [
                    '$tags',
                    (req.body.removedTags || []).map((tag: string) => {
                      return Types.ObjectId.createFromHexString(tag);
                    }),
                  ],
                },
                (req.body.tags || []).map((tag: string) => {
                  return Types.ObjectId.createFromHexString(tag);
                }),
              ],
            },
          },
        },
      ],
    });

    if (!updatedPost) {
      if (attachments?.length) {
        await deleteFiles({ urls: attachments });
      }
      throw new BadRequestException('Failed to update post');
    } else {
      if (req.body.removedAttachments?.length) {
        await deleteFiles({ urls: req.body.removedAttachments });
      }
    }

    return successResponse({ res });
  };

  likePost = async (req: Request, res: Response): Promise<Response> => {
    const { postId } = req.params as { postId: string };
    const { action } = req.query as LikePostQueryInputsDto;
    let update: UpdateQuery<HPostDocument> = {
      $addToSet: { likes: req.user?._id },
    };

    if (action === LikeActionEnum.unlike) {
      update = { $pull: { likes: req.user?._id } };
    }

    const post = await this.postModel.findOneAndUpdate({
      filter: {
        _id: postId,
        $or: postAvailability(req),
      },
      update,
    });
    if (!post) {
      throw new NotFoundException('Post not found');
    }

    return successResponse({ res });
  };

  postList = async (req: Request, res: Response): Promise<Response> => {
    let { page, size } = req.query as unknown as {
      page: number;
      size: number;
    };
    const posts = await this.postModel.paginate({
      filter: {
        $or: postAvailability(req),
      },
      options: {
        populate: [
          {
            path: 'comments',
            match: {
              commentId: { $exists: false },
              freezedAt: { $exists: false },
            },
            populate: [
              {
                path: 'reply',
                match: {
                  commentId: { $exists: false },
                  freezedAt: { $exists: false },
                },
                populate: [
                  {
                    path: 'reply on reply',
                    match: {
                      commentId: { $exists: false },
                      freezedAt: { $exists: false },
                    },
                  },
                ],
              },
            ],
          },
        ],
      },
      page,
      size,
    });

    //   const posts = await this.postModel.findCursor({
    //     filter: {
    //       $or: postAvailability(req),
    //     },
    //   });
    return successResponse({ res, data: { posts } });
  };
}

export const postService = new PostService();
===== SocialApp\src\modules\post\post.validation.ts =====
import z from 'zod';
import {
  AllowCommentsEnum,
  AvailabilityEnum,
  LikeActionEnum,
} from '../../DB/models/Post.model';
import { fileValidation } from '../../utils/multer/cloud.multer';
import { Types } from 'mongoose';
import { generalFields } from '../../middlewares/validation.middleware';

export const createPost = {
  body: z
    .strictObject({
      content: z.string().min(2).max(500000).optional(),
      attachments: z
        .array(generalFields.file(fileValidation.image))
        .max(2)
        .optional(),
      availability: z.enum(AvailabilityEnum).default(AvailabilityEnum.public),
      allowComments: z.enum(AllowCommentsEnum).default(AllowCommentsEnum.allow),
      tags: z.array(generalFields.id).max(10).optional(),
    })
    .superRefine((data, ctx) => {
      if (!data.attachments?.length && !data.content) {
        ctx.addIssue({
          code: 'custom',
          path: ['content'],
          message: 'Either content or attachments must be provided',
        });
      }

      if (
        data.tags?.length &&
        data.tags.length !== [...new Set(data.tags)].length
      ) {
        ctx.addIssue({
          code: 'custom',
          path: ['tags'],
          message: 'Duplicated tagged users',
        });
      }
    }),
};

export const updatePost = {
  params: z.strictObject({ postId: generalFields.id }),
  body: z
    .strictObject({
      content: z.string().min(2).max(500000).optional(),
      availability: z.enum(AvailabilityEnum).optional(),
      allowComments: z.enum(AllowCommentsEnum).optional(),

      attachments: z.array(generalFields.file(fileValidation.image)).max(2).optional(),
      removedAttachments: z.array(z.string()).max(2).optional(),

      tags: z.array(generalFields.id).max(10).optional(),
      removedTags: z.array(generalFields.id).max(10).optional(),
    })
    .superRefine((data, ctx) => {
      if (!Object.values(data)?.length) {
        ctx.addIssue({
          code: 'custom',
          path: ['content'],
          message: 'all fields are empty',
        });
      }

      if (
        data.tags?.length &&
        data.tags.length !== [...new Set(data.tags)].length
      ) {
        ctx.addIssue({
          code: 'custom',
          path: ['tags'],
          message: 'Duplicated tagged users',
        });
      }

      if (
        data.removedTags?.length &&
        data.removedTags.length !== [...new Set(data.removedTags)].length
      ) {
        ctx.addIssue({
          code: 'custom',
          path: ['removedTags'],
          message: 'Duplicated removedTags users',
        });
      }
    }),
};

export const likePost = {
  params: z.strictObject({
    postId: generalFields.id,
  }),
  query: z.strictObject({
    action: z.enum(LikeActionEnum).default(LikeActionEnum.like),
  }),
};
===== SocialApp\src\modules\user\index.ts =====
export { default as router } from './user.controller';
===== SocialApp\src\modules\user\user.authorization.ts =====
import { RoleEnum } from '../../DB/models/User.model';

export const endpoint = {
  profile: [RoleEnum.user],
  restoreAccount: [RoleEnum.admin],
  hardDeleteAccount: [RoleEnum.admin],
  dashboard: [RoleEnum.admin, RoleEnum.superAdmin],
  changeRole: [RoleEnum.admin, RoleEnum.superAdmin],
};
===== SocialApp\src\modules\user\user.controller.ts =====
import { fileValidation, StorageEnum } from './../../utils/multer/cloud.multer';
import { Router } from 'express';
import userServices from './user.service';
import {
  authentication,
  authorization,
} from '../../middlewares/authentication.middleware';
import { validation } from '../../middlewares/validation.middleware';
import * as validators from './user.validation';
import { TokenEnum } from '../../utils/security/token.security';
import { couldFileUpload } from '../../utils/multer/cloud.multer';
import { endpoint } from './user.authorization';

const router = Router();

router.get('/', authentication(), userServices.profile);

router.get(
  '/dashboard',
  authorization(endpoint.dashboard),
  userServices.dashboard
);

router.post(
  '/:userId/send-friend-request',
  authentication(),
  validation(validators.sendFriendRequest),
  userServices.sendFriendRequest
);

router.patch(
  '/accept-friend-request/:friendRequestId',
  authentication(),
  validation(validators.acceptFriendRequest),
  userServices.acceptFriendRequest
);

router.patch(
  '/:userId/change-role',
  authorization(endpoint.changeRole),
  validation(validators.changeRole),
  userServices.changeRole
);

router.post(
  '/refresh-token',
  authentication(TokenEnum.refresh),
  userServices.refreshToken
);
router.post(
  '/logout',
  authentication(),
  validation(validators.logout),
  userServices.logout
);

router.patch('/profile-image', authentication(), userServices.profileImage);
router.patch(
  '/profile-cover-image',
  authentication(),
  couldFileUpload({
    validation: fileValidation.image,
    storageApproach: StorageEnum.disk,
  }).array('images', 2),
  userServices.profileCoverImage
);

router.delete(
  '/freeze-account{/:userId}',
  authentication(),
  validation(validators.freezeAccount),
  userServices.freezeAccount
);

router.delete(
  '/hard-delete-account/:userId',
  authorization(endpoint.hardDeleteAccount),
  validation(validators.hardDeleteAccount),
  userServices.hardDeleteAccount
);

router.patch(
  '/restore-account/:userId',
  authorization(endpoint.hardDeleteAccount),
  validation(validators.restoreAccount),
  userServices.restoreAccount
);

export default router;
===== SocialApp\src\modules\user\user.dto.ts =====
import { z } from 'zod';
import {
  freezeAccount,
  hardDeleteAccount,
  logout,
  restoreAccount,
} from './user.validation';

export type ILogoutBodyInputsDTO = z.infer<typeof logout.body>;

export type IFreezeAccountParamsInputsDTO = z.infer<
  typeof freezeAccount.params
>;

export type IRestoreAccountParamsInputsDTO = z.infer<
  typeof restoreAccount.params
>;

export type IHardDeleteAccountParamsInputsDTO = z.infer<
  typeof hardDeleteAccount.params
>;
===== SocialApp\src\modules\user\user.entities.ts =====
import { HUserDocument } from '../../DB/models/User.model';
import { ILoginResponse } from '../auth/auth.entities';

export interface IProfileResponse {
  user: Partial<HUserDocument>;
}

export interface IProfileImageResponse {
  url: string;
}

export interface IProfileCoverImageResponse extends IProfileResponse {}

export interface IRefreshTokenResponse extends ILoginResponse {}
===== SocialApp\src\modules\user\user.service.ts =====
import { HUserDocument, RoleEnum, UserModel } from '../../DB/models/User.model';
import { Request, Response } from 'express';
import {
  IFreezeAccountParamsInputsDTO,
  IHardDeleteAccountParamsInputsDTO,
  ILogoutBodyInputsDTO,
  IRestoreAccountParamsInputsDTO,
} from './user.dto';
import { IUser } from '../../DB/models/User.model';
import { Types, UpdateQuery } from 'mongoose';
import {
  createLoginCredentials,
  createRevokedToken,
  LogoutEnum,
} from '../../utils/security/token.security';
import {
  UserRepository,
  TokenRepository,
  PostRepository,
  FriendRequestRepository,
} from '../../DB/repository';
import { TokenModel } from '../../DB/models/Token.model';
import { JwtPayload } from 'jsonwebtoken';
import {
  createPreSignedUploadLink,
  deleteFiles,
  deleteFolderByPrefix,
  uploadFile,
  uploadFiles,
  uploadLargeFile,
} from '../../utils/multer/s3.config';
import { StorageEnum } from '../../utils/multer/cloud.multer';
import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  NotFoundException,
  UnauthorizedException,
} from '../../utils/response/error.response';
import { s3Event } from '../../utils/event/s3.event';
import { successResponse } from '../../utils/response/success.response';
import {
  IProfileCoverImageResponse,
  IProfileImageResponse,
  IProfileResponse,
  IRefreshTokenResponse,
} from './user.entities';
import { FriendRequestModel, PostModel } from '../../DB';

class UserServices {
  private userModel = new UserRepository(UserModel);
  private postModel = new PostRepository(PostModel);
  private friendRequestModel = new FriendRequestRepository(FriendRequestModel);

  constructor() {}

  profile = async (req: Request, res: Response): Promise<Response> => {
    const profile = await this.userModel.findById({
      id: req.user?._id as Types.ObjectId,
      options: {
        populate: [
          {
            path: 'friends',
            select: 'firstName lastName email gender profileImage',
          },
        ],
      },
    });
    if (!profile) {
      throw new NotFoundException('fail to fetch user profile');
    }
    return successResponse<IProfileResponse>({ res, data: { user: profile } });
  };

  dashboard = async (req: Request, res: Response): Promise<Response> => {
    const result = await Promise.allSettled([
      this.userModel.find({ filter: {} }),
      this.postModel.find({ filter: {} }),
    ]);
    return successResponse({ res, data: { result } });
  };

  changeRole = async (req: Request, res: Response): Promise<Response> => {
    const { userId } = req.params as unknown as { userId: Types.ObjectId };
    const { role }: { role: RoleEnum } = req.body;

    let denyRoles: RoleEnum[] = [role, RoleEnum.superAdmin];

    if (req.user?.role === RoleEnum.admin) {
      denyRoles.push(RoleEnum.admin);
    }

    const user = await this.userModel.findOneAndUpdate({
      filter: { _id: userId as Types.ObjectId, role: { $nin: denyRoles } },
      update: { role },
    });

    if (!user) {
      throw new NotFoundException('user not found');
    }

    return successResponse({ res });
  };

  sendFriendRequest = async (
    req: Request,
    res: Response
  ): Promise<Response> => {
    const { userId } = req.params as unknown as { userId: Types.ObjectId };

    const checkFriendRequestExist = await this.friendRequestModel.findOne({
      filter: {
        createdBy: { $in: [req.user?._id, userId] },
        sendTo: { $in: [req.user?._id, userId] },
      },
    });

    if (checkFriendRequestExist) {
      throw new ConflictException('friend request already exist');
    }

    const user = await this.userModel.findOne({
      filter: {
        _id: userId,
      },
    });

    if (!user) {
      throw new NotFoundException('invalid recipient user');
    }

    const [friendRequest] =
      (await this.friendRequestModel.create({
        data: [
          {
            createdBy: req.user?._id as Types.ObjectId,
            sendTo: userId,
          },
        ],
      })) || [];

    if (!friendRequest) {
      throw new BadRequestException('fail to create friend request');
    }

    return successResponse({ res, statusCode: 201 });
  };

  acceptFriendRequest = async (
    req: Request,
    res: Response
  ): Promise<Response> => {
    const { friendRequestId } = req.params as unknown as {
      friendRequestId: Types.ObjectId;
    };

    const friendRequest = await this.friendRequestModel.findOneAndUpdate({
      filter: {
        _id: friendRequestId,
        sendTo: req.user?._id,
        acceptedAt: { $exists: false },
      },
      update: {
        acceptedAt: new Date(),
      },
    });

    if (!friendRequest) {
      throw new NotFoundException('fail to find matching result');
    }

    await Promise.all([
      await this.userModel.updateOne({
        filter: { _id: friendRequest.createdBy },
        update: {
          $addToSet: { friends: friendRequest.sendTo },
        },
      }),
      await this.userModel.updateOne({
        filter: { _id: friendRequest.sendTo },
        update: {
          $addToSet: { friends: friendRequest.createdBy },
        },
      }),
    ]);

    return successResponse({ res });
  };

  freezeAccount = async (req: Request, res: Response): Promise<Response> => {
    const { userId } = (req.params as IFreezeAccountParamsInputsDTO) || {};
    if (userId && req.user?.role !== RoleEnum.admin) {
      throw new ForbiddenException('not authorized user');
    }

    const user = await this.userModel.updateOne({
      filter: { _id: userId || req.user?._id, freezedAt: { $exists: false } },
      update: {
        freezedAt: new Date(),
        freezedBy: req.user?._id,
        changeCredentialsTime: new Date(),
        $unset: { restoredAt: 1, restoredBy: 1 },
      },
    });

    if (!user.modifiedCount) {
      throw new NotFoundException('user not found or already freezed');
    }

    return successResponse({ res });
  };

  restoreAccount = async (req: Request, res: Response): Promise<Response> => {
    const { userId } = req.params as IRestoreAccountParamsInputsDTO;

    const user = await this.userModel.updateOne({
      filter: { _id: userId, freezedBy: { $ne: userId } },
      update: {
        restoredAt: new Date(),
        restoredBy: req.user?._id,
        $unset: { freezedAt: 1, freezedBy: 1 },
      },
    });

    if (!user.modifiedCount) {
      throw new NotFoundException('user not found or freezed by account owner');
    }

    return successResponse({ res });
  };

  hardDeleteAccount = async (
    req: Request,
    res: Response
  ): Promise<Response> => {
    const { userId } = req.params as IHardDeleteAccountParamsInputsDTO;

    const user = await this.userModel.deleteOne({
      filter: { _id: userId, freezedAt: { $exists: true } },
    });

    if (!user.deletedCount) {
      throw new NotFoundException('user not found or not freezed');
    }

    await deleteFolderByPrefix({ path: `users/${userId}` });

    return successResponse({ res });
  };

  profileImage = async (req: Request, res: Response): Promise<Response> => {
    const {
      ContentType,
      OriginalName,
    }: { ContentType: string; OriginalName: string } = req.body;

    const { url, key } = await createPreSignedUploadLink({
      ContentType,
      OriginalName,
      path: `users/${req.tokenPayload?._id}`,
    });

    const user = await this.userModel.findByIdAndUpdate({
      id: req.user?._id as Types.ObjectId,
      update: { profileImage: key, temProfileImage: req.user?.profileImage },
    });

    if (!user) {
      throw new BadRequestException('fail to update user profile image');
    }

    s3Event.emit('trackProfileImage', {
      userId: req.user?._id,
      oldKey: req.user?.profileImage,
      key,
      expiresIn: 60000,
    });

    return successResponse<IProfileImageResponse>({ res, data: { url } });
  };

  profileCoverImage = async (
    req: Request,
    res: Response
  ): Promise<Response> => {
    const urls = await uploadFiles({
      storageApproach: StorageEnum.disk,
      files: req.files as Express.Multer.File[],
      path: `users/${req.tokenPayload?._id}/cover`,
      useLarge: true,
    });

    const user = await this.userModel.findByIdAndUpdate({
      id: req.user?._id as Types.ObjectId,
      update: {
        coverImages: urls,
      },
    });

    if (!user) {
      throw new BadRequestException('fail to update user cover images');
    }

    if (req.user?.coverImages) {
      await deleteFiles({ urls: req.user.coverImages });
    }

    return successResponse<IProfileCoverImageResponse>({ res, data: { user } });
  };

  logout = async (req: Request, res: Response): Promise<Response> => {
    const { flag }: ILogoutBodyInputsDTO = req.body;
    let statusCode: number = 200;
    const update: UpdateQuery<IUser> = {};
    switch (flag) {
      case LogoutEnum.all:
        update.changeCredentialsTime = new Date();

        break;

      default:
        await createRevokedToken(req.tokenPayload as JwtPayload);
        statusCode = 201;
        break;
    }

    await this.userModel.updateOne({
      filter: { _id: req.tokenPayload?._id },
      update,
    });

    return successResponse({ res, statusCode });
  };

  refreshToken = async (req: Request, res: Response): Promise<Response> => {
    const credentials = await createLoginCredentials(req.user as HUserDocument);
    await createRevokedToken(req.tokenPayload as JwtPayload);
    return successResponse<IRefreshTokenResponse>({
      res,
      statusCode: 201,
      data: { credentials },
    });
  };
}

export default new UserServices();
===== SocialApp\src\modules\user\user.validation.ts =====
import { generalFields } from './../../middlewares/validation.middleware';
import { z } from 'zod';
import { LogoutEnum } from '../../utils/security/token.security';
import { Types } from 'mongoose';
import { RoleEnum } from '../../DB';

export const logout = {
  body: z.strictObject({
    flag: z.enum(LogoutEnum).default(LogoutEnum.only),
  }),
};
export const sendFriendRequest = {
  params: z.strictObject({
    userId: generalFields.id,
  }),
};
export const acceptFriendRequest = {
  params: z.strictObject({
    friendRequestId: generalFields.id,
  }),
};
export const changeRole = {
  params: sendFriendRequest.params,
  body: z.strictObject({
    role: z.enum(RoleEnum),
  }),
};
export const freezeAccount = {
  params: z
    .object({
      userId: z.string().optional(),
    })
    .optional()
    .refine(
      (data) => {
        return data?.userId ? Types.ObjectId.isValid(data.userId) : true;
      },
      {
        message: 'Invalid userId format',
        path: ['userId'],
      }
    ),
};

export const restoreAccount = {
  params: z
    .object({
      userId: z.string(),
    })
    .refine(
      (data) => {
        return Types.ObjectId.isValid(data.userId);
      },
      {
        message: 'Invalid userId format',
        path: ['userId'],
      }
    ),
};

export const hardDeleteAccount = restoreAccount;
===== SocialApp\src\modules\index.ts =====
export { router as authRouter } from './auth';
export { router as userRouter } from './user';
export { router as postRouter } from './post';
===== SocialApp\src\utils\email\email.template.ts =====
export const EmailTemplate = ({
  otp,
  name,
  title,
}: {
  otp: string;
  name: string;
  title: string;
}): string => {
  const currentYear = new Date().getFullYear();

  return `<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f2f4f8;
    }
    .email-container {
      max-width: 620px;
      margin: 30px auto;
      background-color: #ffffff;
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 8px 25px rgba(0,0,0,0.08);
      border: 1px solid #e6e9ee;
    }
    .email-header {
      background: linear-gradient(135deg, #6a5af9, #ff4ecd);
      color: #ffffff;
      text-align: center;
      padding: 35px 25px;
    }
    .email-header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.5px;
      font-weight: 600;
    }
    .email-body {
      padding: 28px;
      color: #2d3436;
      line-height: 1.7;
      font-size: 16px;
    }
    .email-body h2 {
      margin-top: 0;
      color: #6a5af9;
      font-size: 22px;
      font-weight: 600;
    }
    .activation-code {
      display: inline-block;
      background: #6a5af9;
      color: #ffffff !important;
      padding: 14px 30px;
      border-radius: 10px;
      font-size: 22px;
      margin: 25px 0;
      font-weight: bold;
      letter-spacing: 3px;
      box-shadow: 0 4px 12px rgba(106, 90, 249, 0.25);
    }
    .email-footer {
      text-align: center;
      padding: 22px;
      background-color: #f8f9fb;
      font-size: 14px;
      color: #8d99ae;
    }
    .email-footer a {
      color: #6a5af9;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="email-container">
    <div class="email-header">
      <h1>${title}</h1>
    </div>
    <div class="email-body">
      <h2>Hello ${name}, ðŸ‘‹</h2>
      <p>Welcome to <strong>SocialApp</strong> â€” your new space to share, connect, and express yourself ðŸŒâœ¨</p>
      <p>Please use the verification code below to complete your action:</p>

      <div class="activation-code">${otp}</div>

      <p>This code is valid for a short time. If you didnâ€™t request this, you can safely ignore this email.</p>
      <p>Best regards,<br><strong>SocialApp Team</strong></p>
    </div>
    <div class="email-footer">
      <p>&copy; ${currentYear} SocialApp. All rights reserved.</p>
      <p><a href="#">Contact Support</a> â€¢ <a href="#">Privacy Policy</a></p>
    </div>
  </div>
</body>
</html>`;
};
===== SocialApp\src\utils\email\index.ts =====
export * from './email.template';
export * from './send.email';
===== SocialApp\src\utils\email\send.email.ts =====
import { createTransport, type Transporter } from 'nodemailer';
import Mail from 'nodemailer/lib/mailer';
import SMTPTransport from 'nodemailer/lib/smtp-transport';
import { BadRequestException } from '../response/error.response';

export const sendEmail = async (data: Mail.Options): Promise<void> => {
  if (!data.html && !data.attachments && !data.text) {
    throw new BadRequestException('Missing email content â—');
  }

  const transporter: Transporter<
    SMTPTransport.SentMessageInfo,
    SMTPTransport.Options
  > = createTransport({
    service: 'gmail',
    auth: {
      user: process.env.EMAIL as string,
      pass: process.env.EMAIL_PASSWORD as string,
    },
  });

  const info = await transporter.sendMail({
    ...data,
    from: `"${process.env.APPLICATION_NAME}" <${process.env.EMAIL as string}>`,
    //   to: 'bar@example.com, baz@example.com',
    //   subject: 'Hello âœ”',
    //   text: 'Hello world?', // plainâ€‘text body
    //   html: '<b>Hello world?</b>', // HTML body
  });

  console.log('Message sent:', info.messageId);
};
===== SocialApp\src\utils\event\email.event.ts =====
import { EventEmitter } from 'node:events';
import Mail from 'nodemailer/lib/mailer';
import { sendEmail } from '../email/send.email';
import { EmailTemplate } from '../email/email.template';

export interface IEmail extends Mail.Options {
  otp: string;
  name: string;
}

export const emailEvent = new EventEmitter();

emailEvent.on('confirmEmail', async (data: IEmail) => {
  try {
    data.subject = 'Confirm_Email';
    data.html = EmailTemplate({
      otp: data.otp,
      name: data.name,
      title: 'Email Confirmation',
    });
    await sendEmail(data);
  } catch (error) {
    console.log('Fail to send email âŒ', error);
  }
});

emailEvent.on('resetPasswordOTP', async (data: IEmail) => {
  try {
    data.subject = 'Reset-Account-Password';
    data.html = EmailTemplate({
      otp: data.otp,
      name: data.name,
      title: 'Reset Code',
    });
    await sendEmail(data);
  } catch (error) {
    console.log('Fail to send email âŒ', error);
  }
});

/**
 * export const EmailTemplate = ({
   otp,
   name,
   title,
 */
===== SocialApp\src\utils\event\index.ts =====
export * from './email.event';
export * from './s3.event';
===== SocialApp\src\utils\event\s3.event.ts =====
import { EventEmitter } from 'node:events';
import { deleteFile, getFile } from '../multer/s3.config';
import { HUserDocument, UserModel } from '../../DB/models/User.model';
import { UserRepository } from '../../DB/repository';
import { UpdateQuery } from 'mongoose';

export const s3Event = new EventEmitter();

s3Event.on('trackProfileImage', (data) => {
  // console.log(data);

  setTimeout(async () => {
    const userModel = new UserRepository(UserModel);
    try {
      await getFile({ Key: data.key });
      await userModel.updateOne({
        filter: { _id: data.userId },
        update: { $unset: { temProfileImage: 1 } },
      });
      await deleteFile({ Key: data.oldKey });
      // console.log('Done ðŸŒºðŸ‘ŒðŸ»');
    } catch (error: any) {
      let unsetData: UpdateQuery<HUserDocument> = { temProfileImage: 1 };
      if (!data.oldKey) {
        unsetData = { temProfileImage: 1, profileImage: 1 };
      }
      // console.log(error.Code);
      if (error.Code === 'NoSuchKey') {
        await userModel.updateOne({
          filter: { _id: data.userId },
          update: { profileImage: data.oldKey, $unset: unsetData },
        });
      }
    }
  }, data.expiresIn || Number(process.env.AWS_PRE_SIGNED_URL_EXPIRES_IN_SECONDS) * 1000);
});
===== SocialApp\src\utils\helpers\index.ts =====
export * from './otp';
===== SocialApp\src\utils\helpers\otp.ts =====
export const generateNumberOtp = (): string => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};
===== SocialApp\src\utils\multer\cloud.multer.ts =====
import { Request } from 'express';
import multer, { FileFilterCallback } from 'multer';
import os from 'os';
import { BadRequestException } from '../response/error.response';

export enum StorageEnum {
  memory = 'memory',
  disk = 'disk',
}

export const fileValidation = {
  image: ['image/jpeg', 'image/png', 'image/gif'],
};

export const couldFileUpload = ({
  validation = [],
  storageApproach = StorageEnum.memory,
  maxSizeMB = 2,
}: {
  validation?: string[];
  storageApproach?: StorageEnum;
  maxSizeMB?: number;
}): multer.Multer => {
  const storage =
    storageApproach === StorageEnum.memory
      ? multer.memoryStorage()
      : multer.diskStorage({
          destination: os.tmpdir(),
          filename: function (
            req: Request,
            file: Express.Multer.File,
            callback
          ) {
            callback(null, Date.now() + '-' + file.originalname);
          },
        });

  function fileFilter(
    req: Request,
    file: Express.Multer.File,
    callback: FileFilterCallback
  ) {
    if (!validation.includes(file.mimetype)) {
      return callback(
        new BadRequestException('Invalid file type', {
          validationError: [
            {
              key: 'file',
              issue: [{ path: 'file', message: 'Invalid file type' }],
            },
          ],
        })
      );
    }
    return callback(null, true);
  }

  return multer({
    fileFilter,
    limits: { fileSize: maxSizeMB * 1024 * 1024 },
    storage,
  });
};
===== SocialApp\src\utils\multer\index.ts =====
export * from './cloud.multer';
export * from './s3.config';
===== SocialApp\src\utils\multer\s3.config.ts =====
import { v4 as uuid } from 'uuid';
import {
  DeleteObjectCommand,
  DeleteObjectCommandOutput,
  DeleteObjectsCommand,
  DeleteObjectsCommandOutput,
  GetObjectCommand,
  GetObjectCommandOutput,
  ListObjectsV2Command,
  ObjectCannedACL,
  PutObjectCommand,
  S3Client,
} from '@aws-sdk/client-s3';
import { StorageEnum } from './cloud.multer';
import { createReadStream } from 'node:fs';
import { BadRequestException } from '../response/error.response';
import { Upload } from '@aws-sdk/lib-storage';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

export const s3Config = () => {
  return new S3Client({
    region: process.env.AWS_REGION as string,
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID as string,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY as string,
    },
  });
};

export const uploadFile = async ({
  storageApproach = StorageEnum.memory,
  Bucket = process.env.AWS_BUCKET_NAME as string,
  ACL = 'private',
  path = 'general',
  file,
}: {
  storageApproach?: StorageEnum;
  Bucket?: string;
  ACL?: ObjectCannedACL;
  path?: string;
  file: Express.Multer.File;
}): Promise<string> => {
  const command = new PutObjectCommand({
    Bucket,
    ACL,
    Key: `${process.env.APPLICATION_NAME}/${path}/${uuid()}_${
      file.originalname
    }`,
    Body:
      storageApproach === StorageEnum.memory
        ? file.buffer
        : createReadStream(file.path),
    ContentType: file.mimetype,
  });

  await s3Config().send(command);

  if (!command?.input?.Key) {
    throw new BadRequestException('File upload failed');
  }

  return command.input.Key;
};

export const uploadLargeFile = async ({
  storageApproach = StorageEnum.disk,
  Bucket = process.env.AWS_BUCKET_NAME,
  ACL = 'private',
  path = 'general',
  file,
}: {
  storageApproach?: StorageEnum;
  Bucket?: string;
  ACL?: ObjectCannedACL;
  path?: string;
  file: Express.Multer.File;
}) => {
  const upload = new Upload({
    client: s3Config(),
    params: {
      Bucket,
      ACL,
      Key: `${process.env.APPLICATION_NAME}/${path}/${uuid()}_${
        file.originalname
      }`,
      Body:
        storageApproach === StorageEnum.memory
          ? file.buffer
          : createReadStream(file.path),
      ContentType: file.mimetype,
    },
  });

  upload.on('httpUploadProgress', (progress) => {
    console.log('Upload Progress:', progress);
  });

  const { Key } = await upload.done();

  if (!Key) {
    throw new BadRequestException('File upload failed');
  }

  return Key;
};

export const uploadFiles = async ({
  storageApproach = StorageEnum.memory,
  Bucket = process.env.AWS_BUCKET_NAME as string,
  ACL = 'private',
  path = 'general',
  files,
  useLarge = false,
}: {
  storageApproach?: StorageEnum;
  Bucket?: string;
  ACL?: ObjectCannedACL;
  path?: string;
  files: Express.Multer.File[];
  useLarge?: boolean;
}): Promise<string[]> => {
  let urls: string[] = [];

  if (useLarge) {
    urls = await Promise.all(
      files.map((file) => {
        return uploadLargeFile({
          storageApproach,
          Bucket,
          ACL,
          path,
          file,
        });
      })
    );
  } else {
    urls = await Promise.all(
      files.map((file) => {
        return uploadFile({
          storageApproach,
          Bucket,
          ACL,
          path,
          file,
        });
      })
    );
  }

  return urls;
};

export const createPreSignedUploadLink = async ({
  Bucket = process.env.AWS_BUCKET_NAME as string,
  path = 'general',
  expiresIn = Number(process.env.AWS_PRE_SIGNED_URL_EXPIRES_IN_SECONDS),
  ContentType,
  OriginalName,
}: {
  Bucket?: string;
  path?: string;
  expiresIn?: number;
  ContentType: string;
  OriginalName: string;
}): Promise<{ url: string; key: string }> => {
  const command = new PutObjectCommand({
    Bucket,
    Key: `${process.env.APPLICATION_NAME}/${path}/${uuid()}_${OriginalName}`,
    ContentType,
  });

  const url = await getSignedUrl(s3Config(), command, { expiresIn });

  if (!url || !command?.input?.Key) {
    throw new BadRequestException('Could not create pre-signed URL');
  }

  return { url, key: command.input.Key };
};

export const createGetPreSignedLink = async ({
  Bucket = process.env.AWS_BUCKET_NAME as string,
  Key,
  expiresIn = Number(process.env.AWS_PRE_SIGNED_URL_EXPIRES_IN_SECONDS),
  download = 'false',
  downloadName = 'dummy',
}: {
  Bucket?: string;
  Key: string;
  expiresIn?: number;
  download?: string;
  downloadName?: string;
}): Promise<string> => {
  const command = new GetObjectCommand({
    Bucket,
    Key,
    ResponseContentDisposition:
      download === 'true'
        ? `attachment; filename="${downloadName || Key.split('/').pop()}"`
        : undefined,
  });

  const url = await getSignedUrl(s3Config(), command, { expiresIn });

  if (!url) {
    throw new BadRequestException('Could not create pre-signed URL');
  }

  return url;
};

export const getFile = async ({
  Bucket = process.env.AWS_BUCKET_NAME as string,
  Key,
}: {
  Bucket?: string;
  Key: string;
}): Promise<GetObjectCommandOutput> => {
  const command = new GetObjectCommand({
    Bucket,
    Key,
  });

  return await s3Config().send(command);
};

export const deleteFile = async ({
  Bucket = process.env.AWS_BUCKET_NAME as string,
  Key,
}: {
  Bucket?: string;
  Key: string;
}): Promise<DeleteObjectCommandOutput> => {
  const command = new DeleteObjectCommand({
    Bucket,
    Key,
  });

  return await s3Config().send(command);
};

export const deleteFiles = async ({
  Bucket = process.env.AWS_BUCKET_NAME as string,
  urls,
  Quiet = false,
}: {
  Bucket?: string;
  urls: string[];
  Quiet?: boolean;
}): Promise<DeleteObjectsCommandOutput> => {
  const Objects = urls.map((url) => {
    return { Key: url };
  });

  const command = new DeleteObjectsCommand({
    Bucket,
    Delete: {
      Objects,
      Quiet,
    },
  });

  return await s3Config().send(command);
};

export const listDirectoryFiles = async ({
  Bucket = process.env.AWS_BUCKET_NAME as string,
  path,
}: {
  Bucket?: string;
  path: string;
}) => {
  const command = new ListObjectsV2Command({
    Bucket,
    Prefix: `${process.env.APPLICATION_NAME}/${path}`,
  });

  return await s3Config().send(command);
};

export const deleteFolderByPrefix = async ({
  path,
}: {
  path: string;
}): Promise<DeleteObjectsCommandOutput> => {
  const fileList = await listDirectoryFiles({
    path,
  });

  if (!fileList?.Contents?.length) {
    throw new BadRequestException('No files found in this directory');
  }
  const urls: string[] = fileList.Contents.map((file) => {
    return file.Key as string;
  });

  return await deleteFiles({ urls });
};
===== SocialApp\src\utils\response\error.response.ts =====
import type { NextFunction, Request, Response } from 'express';

export interface IError extends Error {
  statusCode: number;
}

export class ApplicationException extends Error {
  constructor(
    message: string,
    public statusCode: Number = 400,
    cause?: unknown
  ) {
    super(message, { cause });
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class BadRequestException extends ApplicationException {
  constructor(message: string, cause?: unknown) {
    super(message, 400, cause);
  }
}

export class NotFoundException extends ApplicationException {
  constructor(message: string, cause?: unknown) {
    super(message, 404, cause);
  }
}

export class UnauthorizedException extends ApplicationException {
  constructor(message: string, cause?: unknown) {
    super(message, 401, cause);
  }
}

export class ForbiddenException extends ApplicationException {
  constructor(message: string, cause?: unknown) {
    super(message, 403, cause);
  }
}

export class ConflictException extends ApplicationException {
  constructor(message: string, cause?: unknown) {
    super(message, 409, cause);
  }
}

export const globalErrorHandling = (
  error: IError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  return res.status(error.statusCode || 500).json({
    error_message: error.message || 'âŒ something went wrong !',
    cause: error.cause,
    stack: process.env.MOOD === 'development' ? error.stack : undefined,
    error,
  });
};
===== SocialApp\src\utils\response\index.ts =====
export * from './error.response';
export * from './success.response';
===== SocialApp\src\utils\response\success.response.ts =====
import type { Response } from 'express';

export const successResponse = <T = any | null>({
  res,
  message = 'Done',
  statusCode = 200,
  data,
}: {
  res: Response;
  message?: string;
  statusCode?: number;
  data?: T;
}): Response => {
  return res.status(statusCode).json({ message, statusCode, data });
};
===== SocialApp\src\utils\security\hash.security.ts =====
import { hash , compare } from 'bcrypt';

export const generateHash = async (
  plaintext: string,
  saltRound: number = Number(process.env.SALT_ROUND)
):Promise<string> => {
  return await hash(plaintext, saltRound);
};

export const compareHash = async (
  plaintext: string,
  hash:string
):Promise<boolean> => {
  return await compare(plaintext, hash);
};

===== SocialApp\src\utils\security\index.ts =====
export * from './hash.security';
export * from './token.security';
===== SocialApp\src\utils\security\token.security.ts =====
import { v4 as uuid } from 'uuid';
import type { JwtPayload, Secret, SignOptions } from 'jsonwebtoken';
import { decode, sign, verify } from 'jsonwebtoken';
import { HUserDocument, RoleEnum, UserModel } from '../../DB/models/User.model';
import {
  BadRequestException,
  UnauthorizedException,
} from '../response/error.response';
import { UserRepository, TokenRepository } from '../../DB/repository';
import { HTokenDocument, TokenModel } from '../../DB/models/Token.model';

export enum SignatureLevelEnum {
  Bearer = 'Bearer',
  System = 'System',
}

export enum TokenEnum {
  access = 'access',
  refresh = 'refresh',
}
export enum LogoutEnum {
  only = 'only',
  all = 'all',
}

export const generateToken = async ({
  payload,
  secret = process.env.ACCESS_USER_TOKEN_SIGNATURE as string,
  options = { expiresIn: Number(process.env.ACCESS_TOKEN_EXPIRED_IN) },
}: {
  payload: object;
  secret?: Secret;
  options?: SignOptions;
}): Promise<string> => {
  return sign(payload, secret, options);
};

export const verifyToken = async ({
  token,
  secret = process.env.ACCESS_USER_TOKEN_SIGNATURE as string,
}: {
  token: string;
  secret?: Secret;
}): Promise<JwtPayload> => {
  return verify(token, secret) as JwtPayload;
};

export const detectSignatureLevel = async (
  role: RoleEnum = RoleEnum.user
): Promise<SignatureLevelEnum> => {
  let signatureLevel: SignatureLevelEnum = SignatureLevelEnum.Bearer;

  switch (role) {
    case RoleEnum.admin:
    case RoleEnum.superAdmin:
      signatureLevel = SignatureLevelEnum.System;
      break;

    default:
      signatureLevel = SignatureLevelEnum.Bearer;
      break;
  }

  return signatureLevel;
};

export const getSignatures = async (
  signatureLevel: SignatureLevelEnum = SignatureLevelEnum.Bearer
): Promise<{ access_signature: string; refresh_signature: string }> => {
  let signatures: { access_signature: string; refresh_signature: string } = {
    access_signature: '',
    refresh_signature: '',
  };

  switch (signatureLevel) {
    case SignatureLevelEnum.System:
      signatures.access_signature = process.env
        .ACCESS_SYSTEM_TOKEN_SIGNATURE as string;
      signatures.refresh_signature = process.env
        .REFRESH_SYSTEM_TOKEN_SIGNATURE as string;
      break;
    default:
      signatures.access_signature = process.env
        .ACCESS_USER_TOKEN_SIGNATURE as string;
      signatures.refresh_signature = process.env
        .REFRESH_USER_TOKEN_SIGNATURE as string;

      break;
  }
  return signatures;
};

export const createLoginCredentials = async (user: HUserDocument) => {
  const signatureLevel = await detectSignatureLevel(user.role);
  const signatures = await getSignatures(signatureLevel);

  const jwtid = uuid();

  const access_token = await generateToken({
    payload: { _id: user._id, lvl: signatureLevel },
    secret: signatures.access_signature,
    options: { expiresIn: Number(process.env.ACCESS_TOKEN_EXPIRES_IN), jwtid },
  });
  const refresh_token = await generateToken({
    payload: { _id: user._id, lvl: signatureLevel },
    secret: signatures.refresh_signature,
    options: { expiresIn: Number(process.env.REFRESH_TOKEN_EXPIRES_IN), jwtid },
  });

  return { access_token, refresh_token };
};

export const decodeToken = async ({
  authorization,
  tokenType = TokenEnum.access,
}: {
  authorization: string;
  tokenType?: TokenEnum;
}) => {
  const userModel = new UserRepository(UserModel);
  const tokenModel = new TokenRepository(TokenModel);

  const [scheme, token] = authorization.split(' ');
  if (!scheme || !token) {
    throw new UnauthorizedException('Missing token parts');
  }

  if (scheme !== 'Bearer') {
    throw new UnauthorizedException('Invalid authorization scheme');
  }

  const decoded = decode(token) as JwtPayload;

  if (!decoded) {
    throw new UnauthorizedException('Invalid token payload');
  }
  const lvl = decoded.lvl || SignatureLevelEnum.Bearer;

  const signatures = await getSignatures(lvl as SignatureLevelEnum);

  const secret =
    tokenType === TokenEnum.refresh
      ? signatures.refresh_signature
      : signatures.access_signature;

  const verification = await verifyToken({ token, secret });

  if (!verification || !verification._id || !verification.iat) {
    throw new UnauthorizedException('Invalid or expired token');
  }

  if (await tokenModel.findOne({ filter: { jti: verification.jti } })) {
    throw new UnauthorizedException('invalid or old login credentials');
  }

  const user = await userModel.findOne({
    filter: { _id: verification._id },
  });

  if (!user) {
    throw new BadRequestException('Not registered account');
  }

  if ((user.changeCredentialsTime?.getTime() || 0) > verification.iat * 1000) {
    throw new UnauthorizedException('invalid or old login credentials');
  }

  return {
    user,
    tokenPayload: verification,
    level: lvl,
  };
};

export const createRevokedToken = async (
  tokenPayload: JwtPayload
): Promise<HTokenDocument> => {
  const tokenModel = new TokenRepository(TokenModel);

  const [result] =
    (await tokenModel.create({
      data: [
        {
          jti: tokenPayload.jti as string,
          expiresIn:
            (tokenPayload.iat as number) +
            Number(process.env.REFRESH_TOKEN_EXPIRES_IN),
          userId: tokenPayload._id,
        },
      ],
    })) || [];

  if (!result) {
    throw new BadRequestException('Failed to revoke token');
  }

  return result;
};
===== SocialApp\src\utils\types\index.ts =====
export * from './request.express';
===== SocialApp\src\utils\types\request.express.ts =====
import { JwtPayload } from 'jsonwebtoken';
import { HUserDocument } from '../../DB/models/User.model';
import { SignatureLevelEnum } from '../security/token.security';

declare module 'express-serve-static-core' {
  interface Request {
    user?: HUserDocument;
    tokenPayload?: JwtPayload;
    level?: SignatureLevelEnum;
  }
}
===== SocialApp\src\utils\index.ts =====
export * from './email';
export * from './event';
export * from './helpers';
export * from './multer';
export * from './response';
export * from './security';
export * from './types';
===== SocialApp\src\app.controller.ts =====
// ===============================
// ðŸŒŸ Core Imports
// ===============================
import express from 'express';
import type { Express, Request, Response } from 'express';

// ===============================
// ðŸ›¡ï¸ Security & Middleware Packages
// ===============================
import cors from 'cors';
import helmet from 'helmet';
import { rateLimit } from 'express-rate-limit';

// ===============================
// âš™ï¸ Environment Configuration
// ===============================
import { config } from 'dotenv';
import { resolve } from 'node:path';

import { authRouter, postRouter, userRouter } from './modules';
// import { router as authRouter } from './modules/auth';

// // import authRouter from './modules/auth/auth.controller';
// import userRouter from './modules/user/user.controller';
import {
  BadRequestException,
  globalErrorHandling,
} from './utils/response/error.response';
import connectDB from './DB/connection.db';
import { createGetPreSignedLink, getFile } from './utils/multer/s3.config';
config({ path: resolve('./config/.env.development') });

// ===============================
// ðŸ“¦ AWS S3 â€“ File Streaming Setup
// ===============================
import { promisify } from 'node:util';
import { pipeline } from 'node:stream';
const createS3WriteStreamPipe = promisify(pipeline);

// ===============================
// ðŸš¦ Rate Limiter Setup
// ===============================
const limiter = rateLimit({
  windowMs: 60 * 60000,
  limit: 2000,
  message: { error: 'ðŸš¦ Too many request please try again later' },
  statusCode: 429,
});

// ===============================
// ðŸš€ Application Bootstrap
// ===============================
const bootstrap = async (): Promise<void> => {
  const app: Express = express();
  const port: string | number = process.env.PORT || 5000;

  // ===============================
  // ðŸ§° Global Middlewares
  // ===============================
  app.use(express.json());
  app.use(cors());
  app.use(helmet());
  app.use(limiter);

  // ===============================
  // ðŸ  Root Route (Landing Page)
  // ===============================
  app.get('/', (req: Request, res: Response) => {
    res.json({
      message: `Welcome to ${process.env.APPLICATION_NAME} backend landing page â¤ðŸ€ `,
    });
  });

  // ===============================
  // ðŸ” App Router
  // ===============================
  app.use('/auth', authRouter);
  app.use('/user', userRouter);
  app.use('/post', postRouter);

  // ===============================
  // ðŸ“¦ AWS S3 Asset Delivery (Pre-Signed + Direct Streaming)
  // ===============================

  app.get(
    '/upload/pre-signed/*path',
    async (req: Request, res: Response): Promise<Response> => {
      const { downloadName, download = 'false' } = req.query as {
        downloadName?: string;
        download?: string;
      };
      const { path } = req.params as unknown as { path: string[] };

      const Key = path.join('/');

      const url = await createGetPreSignedLink({
        Key,
        downloadName: downloadName as string,
        download,
      });

      return res.json({ message: 'Done', data: { url } });
    }
  );

  app.get(
    '/upload/*path',
    async (req: Request, res: Response): Promise<void> => {
      const { downloadName, download = 'false' } = req.query as {
        downloadName?: string;
        download?: string;
      };

      const { path } = req.params as unknown as { path: string[] };

      const Key = path.join('/');

      const s3Response = await getFile({ Key });

      if (!s3Response.Body) {
        throw new BadRequestException('fail to fetch this asset');
      }

      res.set("Cross-Origin-Resource-Policy","cross-origin");
      res.setHeader(
        'Content-Type',
        s3Response.ContentType || 'application/octet-stream'
      );

      if (download == 'true') {
        res.setHeader(
          'Content-Disposition',
          `attachment; filename="${downloadName || Key.split('/').pop()}"`
        );
      }

      return await createS3WriteStreamPipe(
        s3Response.Body as NodeJS.ReadableStream,
        res
      );
    }
  );

  // ===============================
  // âŒ Invalid Route Handler (Fallback)
  // ===============================
  app.use('{/*dummy}', (req: Request, res: Response) => {
    return res.status(404).json({
      message: 'âŒ Not valid routing, please check the method and URL.',
    });
  });

  // ===============================
  // âŒ Global Error Handler
  // ===============================
  app.use(globalErrorHandling);

  // ðŸ“‚ DataBase
  await connectDB();

  // ===============================
  // ðŸ’¬ Tests
  // ===============================

  // async function test() {
  //   try {
  //     // const user = new UserModel({
  //     //   username: 'zeyad Mohammed',
  //     //   email: `${Date.now()}@gmail.com`,
  //     //   password: 'AVSjsut382',
  //     // });
  //     // await user.save({ validateBeforeSave: true });

  //     // const userModel = new UserRepository(UserModel);
  //     // const user = (await userModel.findOne({
  //     //   filter: { gender: GenderEnum.female },
  //     // })) as HUserDocument;
  //     // console.log({ result: user });

  //     const userModel = new UserRepository(UserModel);
  //     const users = await userModel.find({
  //       filter: { paranoid: false },
  //       options: { limit: 2, skip: 0 },
  //     });
  //     console.log(users);
  //   } catch (error) {
  //     console.log(error);
  //   }
  // }
  // test();

  // ===============================
  // ðŸ“¡ Start Server
  // ===============================
  app.listen(port, () => {
    console.log(`Server is running on port :::${port} ðŸš€`);
  });
};

// ===============================
// ðŸ“¦ Export Bootstrap Function
// ===============================
export default bootstrap;
===== SocialApp\src\index.ts =====
import bootstrap from './app.controller';

bootstrap();
===== SocialApp\.gitignore =====
node_modules
config
dist
===== SocialApp\package.json =====
{
  "name": "socialapp",
  "version": "1.0.0",
  "description": "SocialApp",
  "main": "dist/index.js",
  "scripts": {
    "start": "node --watch dist/index.js",
    "start:dev": "concurrently \"tsc --watch\" \"node --watch dist/index.js\""
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zeyad-mohammed-dev/SocialApp.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/zeyad-mohammed-dev/SocialApp/issues"
  },
  "homepage": "https://github.com/zeyad-mohammed-dev/SocialApp#readme",
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cors": "^2.8.19",
    "@types/dotenv": "^6.1.1",
    "@types/express": "^5.0.5",
    "@types/express-rate-limit": "^5.1.3",
    "@types/helmet": "^0.0.48",
    "@types/multer": "^2.0.0",
    "@types/node": "^24.9.2",
    "@types/nodemailer": "^7.0.3",
    "@types/uuid": "^10.0.0",
    "concurrently": "^9.2.1"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.937.0",
    "@aws-sdk/lib-storage": "^3.937.0",
    "@aws-sdk/s3-request-presigner": "^3.937.0",
    "@types/jsonwebtoken": "^9.0.10",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "express-rate-limit": "^8.2.1",
    "google-auth-library": "^10.5.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.19.3",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.10",
    "uuid": "^13.0.0",
    "zod": "^4.1.12"
  }
}
===== SocialApp\README.md =====
# SocialApp
===== SocialApp\tsconfig.json =====
{
  // Visit https://aka.ms/tsconfig to read more about this file
  "compilerOptions": {
    // File Layout
    "rootDir": "./src",
    "outDir": "./dist",
    "removeComments": true,
    "esModuleInterop": true,
    "verbatimModuleSyntax": false,
    "declaration": false,

    // Environment Settings
    // See also https://aka.ms/tsconfig/module
    "module": "commonjs",
    "target": "es2023",
    // For nodejs:
    // "lib": ["esnext"],
    "types": ["node"],
    "paths": {
      "*": ["./src/utils/types/*"]
    },
    // and npm install -D @types/node

    // Other Outputs
    // "sourceMap": true,
    // "declaration": true,
    // "declarationMap": true,

    // Stricter Typechecking Options
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    // Style Options
    "noImplicitReturns": true,
    "noImplicitOverride": true,
    "noUnusedLocals": false,
    // "noUnusedParameters": true,
    // "noFallthroughCasesInSwitch": true,
    // "noPropertyAccessFromIndexSignature": true,

    // Recommended Options
    "strict": true,
    "jsx": "react-jsx",
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true
  }
}
